"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = mergeLoadBalancingMapFiles;
const deepmerge_1 = __importDefault(require("deepmerge"));
const utils_js_1 = __importDefault(require("./utils.js"));
//eslint-disable-next-line @typescript-eslint/no-explicit-any
const combineMerge = (target, source, options) => {
    const destination = target.slice();
    source.forEach((item, index) => {
        if (typeof destination[index] === "undefined") {
            destination[index] = options === null || options === void 0 ? void 0 : options.cloneUnlessOtherwiseSpecified(item, options);
        }
        else if (options === null || options === void 0 ? void 0 : options.isMergeableObject(item)) {
            destination[index] = (0, deepmerge_1.default)(target[index], item, options);
        }
        else if (target.indexOf(item) === -1) {
            destination.push(item);
        }
    });
    return destination;
};
/**
 * Merges load balancing maps back to an original object.
 * This should be executed after parallel jobs finish
 * to collect their results and merge them to the original master file
 * Does not save the original file, so that will need to be done separately.
 * @param orig {LoadBalancingMap}
 * @param extraMaps {LoadBalancingMap[]}
 */
function mergeLoadBalancingMapFiles(orig, extraMaps) {
    const mergedFile = deepmerge_1.default.all([orig, ...extraMaps], { arrayMerge: combineMerge });
    //TODO: Optimization
    // It would be more efficient to calculate only files with new values.
    // Need to figure out how to determine which files are "new".
    utils_js_1.default.TESTING_TYPES.map((t) => {
        Object.keys(mergedFile[t]).map((f) => utils_js_1.default.updateFileStats(mergedFile, t, f));
    });
    return mergedFile;
}
