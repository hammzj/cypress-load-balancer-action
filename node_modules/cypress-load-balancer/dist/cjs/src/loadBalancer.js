"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = performLoadBalancing;
const node_fs_1 = __importDefault(require("node:fs"));
const utils_1 = __importDefault(require("./utils"));
function prepareFiles(loadBalancingMap, testingType, filePaths = []) {
    if (filePaths.length > 0) {
        filePaths.map((fp) => utils_1.default.createNewEntry(loadBalancingMap, testingType, fp));
        utils_1.default.saveMapFile(loadBalancingMap);
    }
}
function performLoadBalancing(runnerCount, testingType, filePaths) {
    const runners = Array.from({ length: runnerCount }, () => []);
    const matchingIndexAlgorithm = (filePath, filePathIndex) => {
        const i = filePathIndex % runners.length;
        runners[i].push(filePath);
    };
    utils_1.default.initializeLoadBalancingFiles();
    const loadBalancingMap = JSON.parse(node_fs_1.default.readFileSync(utils_1.default.MAIN_LOAD_BALANCING_MAP_FILE_PATH).toString());
    prepareFiles(loadBalancingMap, testingType, filePaths);
    filePaths
        .sort((a, b) => loadBalancingMap[testingType][a].stats.average - loadBalancingMap[testingType][b].stats.average)
        .reverse() //Sort highest to lowest by average
        .map((filePath, filePathIndex) => matchingIndexAlgorithm(filePath, filePathIndex));
    //TODO: consider calculating the average all at once -- more expensive, but less overhead to manage
    // filesToRun
    //     .map(f => Array.from([f, calculateDurationAverage(loadBalancingMap, f)]))
    //     .sort((a, b) => a[1] - b[1])
    //     .reverse() //Sort highest to lowest by average
    //     .map(([filePath, _average], filePathIndex) => matchingIndexAlgorithm(filePath, filePathIndex))
    return runners;
}
